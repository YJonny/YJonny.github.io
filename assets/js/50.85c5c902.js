(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{475:function(v,e,t){"use strict";t.r(e);var _=t(1),a=Object(_.a)({},(function(){var v=this,e=v.$createElement,t=v._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h4",{attrs:{id:"组件通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件通信"}},[v._v("#")]),v._v(" 组件通信")]),v._v(" "),t("ol",[t("li",[v._v("props / $emit")]),v._v(" "),t("li",[v._v("$children / $parent")]),v._v(" "),t("li",[v._v("provide / reject")]),v._v(" "),t("li",[v._v("ref")]),v._v(" "),t("li",[v._v("eventBus")]),v._v(" "),t("li",[v._v("vuex")]),v._v(" "),t("li",[v._v("localStroage / sessionStroage")]),v._v(" "),t("li",[v._v("$attrs / $listeners")])]),v._v(" "),t("h4",{attrs:{id:"的作用是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#的作用是什么"}},[v._v("#")]),v._v(" "),t("keep-alive"),v._v("的作用是什么")],1),v._v(" "),t("p",[v._v("用于需要频繁切换组件缓存，不需要重新渲染页面。")]),v._v(" "),t("h4",{attrs:{id:"如何获取dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何获取dom"}},[v._v("#")]),v._v(" 如何获取dom")]),v._v(" "),t("p",[v._v("给dom元素添加ref='name'，然后通过this.$ref.name来获取dom。")]),v._v(" "),t("h4",{attrs:{id:"为什么用key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么用key"}},[v._v("#")]),v._v(" 为什么用key")]),v._v(" "),t("p",[v._v("便于diff算法识别节点，使页面渲染加快。")]),v._v(" "),t("h4",{attrs:{id:"分别减速computed和watch的使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分别减速computed和watch的使用场景"}},[v._v("#")]),v._v(" 分别减速computed和watch的使用场景")]),v._v(" "),t("ul",[t("li",[v._v("所有需要计算的属性都可以用computed，多条数据影响一条数据时用computed")]),v._v(" "),t("li",[v._v("一条数据影响多条数据时用watch")])]),v._v(" "),t("h4",{attrs:{id:"nexttick的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nexttick的使用"}},[v._v("#")]),v._v(" $nextTick的使用")]),v._v(" "),t("p",[v._v("处理Vue中dom的异步更新。在数据更新后，dom渲染之后自动执行的回调函数。")]),v._v(" "),t("h4",{attrs:{id:"vue组件中的data为什么要以函数的形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue组件中的data为什么要以函数的形式"}},[v._v("#")]),v._v(" vue组件中的data为什么要以函数的形式")]),v._v(" "),t("p",[v._v("以函数返回值的形式出现，保证在使用组件时生成新的data，这样在复用组件时不会造成混乱，各自维护自己的data。单纯使用对象，那么所有组件实例共同拥有一个data。")]),v._v(" "),t("h4",{attrs:{id:"vue双向数据绑定是如何实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue双向数据绑定是如何实现的"}},[v._v("#")]),v._v(" vue双向数据绑定是如何实现的")]),v._v(" "),t("p",[v._v("核心: vue2使用Object.defineProperty(), vue3中使用代理proxy"),t("br"),v._v("\n通过数据劫持结合订阅发布来实现，做到数据更新视图，视图更新数据。")]),v._v(" "),t("h4",{attrs:{id:"父组件和子组件的生命周期加载顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#父组件和子组件的生命周期加载顺序"}},[v._v("#")]),v._v(" 父组件和子组件的生命周期加载顺序")]),v._v(" "),t("ul",[t("li",[v._v("加载渲染过程")])]),v._v(" "),t("blockquote",[t("p",[v._v("父beforeCreate => 父created => 父beforeMount => 子beforeCreate => 子created => 子beforeMount => 子mounted => 父mounted")])]),v._v(" "),t("ul",[t("li",[v._v("子组件更新过程")])]),v._v(" "),t("blockquote",[t("p",[v._v("父beforeUpdate => 子beforeUpdate => 子updated => 父updated")])]),v._v(" "),t("ul",[t("li",[v._v("父组件更新")])]),v._v(" "),t("blockquote",[t("p",[v._v("父beforeUpdate => 父updated")])]),v._v(" "),t("ul",[t("li",[v._v("销毁过程")])]),v._v(" "),t("blockquote",[t("p",[v._v("父beforeDestroy => 子beforeDestroy => 子destroy => 父destroy")])]),v._v(" "),t("h4",{attrs:{id:"delete和vue-delete删除数组的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#delete和vue-delete删除数组的区别"}},[v._v("#")]),v._v(" delete和Vue.delete删除数组的区别")]),v._v(" "),t("p",[v._v("delete删除的元素会变成empty/undefined，数组长度还是不变的。Vue.delete删除的元素，数组长度会改变是真的删除")]),v._v(" "),t("h4",{attrs:{id:"spa首屏加载慢如何解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spa首屏加载慢如何解决"}},[v._v("#")]),v._v(" SPA首屏加载慢如何解决")]),v._v(" "),t("p",[v._v("动态加载；CDN资源服务")]),v._v(" "),t("h4",{attrs:{id:"vue更新视图时触发那些数组方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue更新视图时触发那些数组方法"}},[v._v("#")]),v._v(" vue更新视图时触发那些数组方法")]),v._v(" "),t("p",[v._v("push()；\npop()；\nshift()；\nunshift()；\nsplice()；\nsort()；\nreverse()")]),v._v(" "),t("h4",{attrs:{id:"created和mounted的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#created和mounted的区别"}},[v._v("#")]),v._v(" created和mounted的区别")]),v._v(" "),t("ul",[t("li",[v._v("created：在HTML模板渲染前调用，通常初始化某些属性值，然后再渲染视图")]),v._v(" "),t("li",[v._v("mounted：再HTML模板渲染完成后，通常再初始化页面完成后，再对HTML的dom进行一些需要的操作")])]),v._v(" "),t("h4",{attrs:{id:"vuex有哪几种属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex有哪几种属性"}},[v._v("#")]),v._v(" vuex有哪几种属性")]),v._v(" "),t("p",[v._v("有五种，State、Getter、Mutation、Action、Module")]),v._v(" "),t("ul",[t("li",[v._v("state：基本数据(数据源存放地)")]),v._v(" "),t("li",[v._v("getter：从基本数据派生出的数据")]),v._v(" "),t("li",[v._v("mutations：提交更改数据的方法，同步！")]),v._v(" "),t("li",[v._v("action：像一个装饰器，包裹mutations，使其可以异步")]),v._v(" "),t("li",[v._v("module：模块化vuex")])]),v._v(" "),t("h4",{attrs:{id:"vue常用修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue常用修饰符"}},[v._v("#")]),v._v(" vue常用修饰符")]),v._v(" "),t("p",[t("strong",[v._v("事件修饰符")])]),v._v(" "),t("ul",[t("li",[v._v(".stop 阻止事件继续传播")]),v._v(" "),t("li",[v._v(".prevent 阻止标签默认行为")]),v._v(" "),t("li",[v._v(".capture 使用事件捕获模式，即元素自身触发的事件先在此处处理，然后交由内部元素处理")]),v._v(" "),t("li",[v._v(".self 只有当event.target是当前元素自身时触发处理函数")]),v._v(" "),t("li",[v._v(".once 事件只会触发一次")]),v._v(" "),t("li",[v._v(".passive 告诉浏览器你不想阻止事件的默认行为")])]),v._v(" "),t("p",[t("strong",[v._v("v-model修饰符")])]),v._v(" "),t("ul",[t("li",[v._v(".lazy 通过这个修饰符，转变为在change事件在触发")]),v._v(" "),t("li",[v._v(".number 自动将用户输入值转化为数字")]),v._v(" "),t("li",[v._v(".trim 自动过滤用户输入的收尾空格")])]),v._v(" "),t("p",[t("strong",[v._v("键盘事件修饰符")])]),v._v(" "),t("ul",[t("li",[v._v(".enter")]),v._v(" "),t("li",[v._v(".tab")]),v._v(" "),t("li",[v._v(".delete")]),v._v(" "),t("li",[v._v(".esc")]),v._v(" "),t("li",[v._v(".space")]),v._v(" "),t("li",[v._v(".up")]),v._v(" "),t("li",[v._v(".down")]),v._v(" "),t("li",[v._v(".left")]),v._v(" "),t("li",[v._v(".right")])]),v._v(" "),t("p",[t("strong",[v._v("系统修饰符")])]),v._v(" "),t("ul",[t("li",[v._v(".ctrl")]),v._v(" "),t("li",[v._v(".alt")]),v._v(" "),t("li",[v._v(".shift")]),v._v(" "),t("li",[v._v(".meta")])]),v._v(" "),t("p",[t("strong",[v._v("鼠标按钮修饰符")])]),v._v(" "),t("ul",[t("li",[v._v(".left")]),v._v(" "),t("li",[v._v(".right")]),v._v(" "),t("li",[v._v(".middle")])]),v._v(" "),t("h4",{attrs:{id:"vue事件中如何使用event对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue事件中如何使用event对象"}},[v._v("#")]),v._v(" vue事件中如何使用event对象")]),v._v(" "),t("p",[v._v("获取事件对象，方法参数使用$event传递")]),v._v(" "),t("h4",{attrs:{id:"vue-中子组件调用父组件的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-中子组件调用父组件的方法"}},[v._v("#")]),v._v(" vue 中子组件调用父组件的方法")]),v._v(" "),t("ul",[t("li",[v._v("直接在子组件中通过 this.$parent.event 来调用父组件的方法")]),v._v(" "),t("li",[v._v("在子组件里用$emit()向父组件触发一个事件，父组件监听这个事件就行了")]),v._v(" "),t("li",[v._v("父组件把方法传入子组件中，在子组件里直接调用这个方法")])]),v._v(" "),t("h4",{attrs:{id:"如何获取-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何获取-dom"}},[v._v("#")]),v._v(" 如何获取 dom")]),v._v(" "),t("blockquote",[t("p",[v._v('ref="domName" 使用this.$refs.domName')])]),v._v(" "),t("h4",{attrs:{id:"computed和watch的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch的区别"}},[v._v("#")]),v._v(" Computed和Watch的区别")]),v._v(" "),t("ul",[t("li",[v._v("computed计算属性：依赖其他属性值，并且computer值有缓存，只有它依赖的属性值发生改变，下次获取computed的值才会发生改变")]),v._v(" "),t("li",[v._v("watch侦听器：更多是观察的作用，无缓存性，类似某些数据的侦听回调，当监听的数据发生变化时都会执行回调进行后续操作")]),v._v(" "),t("li",[v._v("运用场景：\n"),t("ul",[t("li",[v._v("当需要进行数据计算，并且依赖其他数据时应该使用computed，可以利用它的数据缓存性避免每次数据改变都要重新计算")]),v._v(" "),t("li",[v._v("当需要在数据变化时进行异步或者开销较大的操作时应该使用watch，使用watch允许我们执行异步操作，限制我们执行该操作的频率，并在得到最终结果前设置中间值，这些计算属性无法做到")]),v._v(" "),t("li",[v._v("多个因素影响一个属性使用computed，一个因素影响其他多个因素使用watch")])])]),v._v(" "),t("li",[v._v("computed和methods的区别\n"),t("ul",[t("li",[v._v("computed：计算属性是基于它们的依赖进行缓存的，只有在相关依赖发生改变时才会重新求值")]),v._v(" "),t("li",[v._v("methods：调用总会执行")])])])]),v._v(" "),t("h4",{attrs:{id:"虚拟dom是什么-有什么优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom是什么-有什么优缺点"}},[v._v("#")]),v._v(" 虚拟dom是什么？有什么优缺点？")]),v._v(" "),t("p",[v._v("虚拟dom是一个js对象，模拟的真是dom节点，是真实dom的抽象")]),v._v(" "),t("ul",[t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，他的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，既保证性能的下限")]),v._v(" "),t("li",[v._v("无需手动操作dom：无需手动操纵dom，只需要写好view-model代码逻辑，就能根据虚拟dom和数据双向绑定来更新视图，提高开发效率")]),v._v(" "),t("li",[v._v("跨平台：虚拟dom本质上是JavaScript对象，而dom与平台强相关；相比虚拟dom可以更好的进行跨平台操作，例如服务端渲染、weex开发等")])])]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[v._v("无法极致优化：在一些性能要求极高的应用中虚拟dom无法进行针对性的性能优化")]),v._v(" "),t("li",[v._v("首次渲染时由于加入了一层dom计算，会比innerHTML插入慢")])])])]),v._v(" "),t("h4",{attrs:{id:"你都做过哪些-vue-的性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#你都做过哪些-vue-的性能优化"}},[v._v("#")]),v._v(" 你都做过哪些 Vue 的性能优化")]),v._v(" "),t("ul",[t("li",[v._v("对象层级不要过深，否则性能就会差。")]),v._v(" "),t("li",[v._v("不需要响应式的数据不要放在 data 中（可以使用 Object.freeze() 冻结数据）")]),v._v(" "),t("li",[v._v("v-if 和 v-show 区分使用场景")]),v._v(" "),t("li",[v._v("computed 和 watch 区分场景使用")]),v._v(" "),t("li",[v._v("v-for 遍历必须加 key，key最好是id值，且避免同时使用 v-if")]),v._v(" "),t("li",[v._v("大数据列表和表格性能优化 - 虚拟列表 / 虚拟表格")]),v._v(" "),t("li",[v._v("防止内部泄露，组件销毁后把全局变量和时间销毁")]),v._v(" "),t("li",[v._v("图片懒加载")]),v._v(" "),t("li",[v._v("路由懒加载")]),v._v(" "),t("li",[v._v("异步路由")]),v._v(" "),t("li",[v._v("第三方插件的按需加载")]),v._v(" "),t("li",[v._v("适当采用 keep-alive 缓存组件")]),v._v(" "),t("li",[v._v("防抖、节流的运用")]),v._v(" "),t("li",[v._v("服务端渲染 SSR or 预渲染")])])])}),[],!1,null,null,null);e.default=a.exports}}]);