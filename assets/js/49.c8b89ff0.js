(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{474:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h4",{attrs:{id:"js变量和函数声明提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js变量和函数声明提升"}},[t._v("#")]),t._v(" js变量和函数声明提升")]),t._v(" "),a("p",[t._v("js中用var声明的变量会提升至最顶部执行，即可以在声明变量之前使用该变量。函数声明也会提升，并且函数声明优先与变量声明，匿名函数不会提升。"),a("br"),t._v("\n由ES6的const和let声明的变量不会提升，所以只能在声明后使用变量，因为此声明会造成暂时性死区，产生块作用域。")]),t._v(" "),a("h4",{attrs:{id:"var、let和const的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#var、let和const的区别"}},[t._v("#")]),t._v(" var、let和const的区别")]),t._v(" "),a("p",[a("strong",[t._v("var")]),t._v(": ES6之前用来声明变量的关键字。声明的变量会提升到作用域的顶端，所以在没有声明变量之前可以使用变量，会返回undefined。可以被重新声明和修改。\n"),a("strong",[t._v("let")]),t._v(": ES6之后用来声明变量的关键字。声明的变量在编译时执行，不会变量提升，所以不能在声明之前使用。不能被重新声明，但是可以修改值。let是块级作用域，声明的变量只能在该块中使用。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// var 声明")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'var声明变量'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// var声明变量")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// let 声明")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'let声明变量'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// b is not defined")]),t._v("\n")])])]),a("p",[a("strong",[t._v("const")]),t._v(": ES6之后用来声明常量的关键字。声明的变量编译时执行，与let一样是块级作用域，不会变量提升，不能重新声明，不能重新赋值，所以必须赋初始值。在对象和数组的声明时，可以更新对象的属性。")]),t._v(" "),a("h4",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("p",[t._v("外部函数可以访问内部函数的变量，一个函数作为另一个函数的返回值。")]),t._v(" "),a("p",[t._v("好处: 保存变量，避免被垃圾回收。可以读取内部函数的变量。\n坏处: 耗内存，内存泄漏。")]),t._v(" "),a("h4",{attrs:{id:"this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),a("p",[t._v("ECMAScript中这样介绍:")]),t._v(" "),a("blockquote",[a("p",[t._v("this 关键字执行为当前执行环境的ThisBinding\nMDN这样介绍:\n在绝大多数情况下，函数的调用方式决定了this的值\n可以理解为，在JavaScript中，this的调用时决定的，而不是在创建时决定的，this具有运行时绑定的特性。"),a("br"),t._v("\n执行期上下文三阶段: 创建，执行，回收。"),a("br"),t._v("\nthis的执行是在创建时被确定的。")])]),t._v(" "),a("h4",{attrs:{id:"map和foreach的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map和foreach的区别"}},[t._v("#")]),t._v(" map和forEach的区别")]),t._v(" "),a("p",[t._v("forEach基础遍历方法，三个参数，当前项，当前项的索引，以及当前遍历的数组。"),a("br"),t._v("\nmap的用法与forEach一样，不同在它返回一个新的数组，所以必须要由返回值，不然就会返回undefined。")]),t._v(" "),a("h4",{attrs:{id:"严格模式限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#严格模式限制"}},[t._v("#")]),t._v(" 严格模式限制")]),t._v(" "),a("ul",[a("li",[t._v("变量必须声明在使用")]),t._v(" "),a("li",[t._v("参数不能有同名属性")]),t._v(" "),a("li",[t._v("不能使用with语句")]),t._v(" "),a("li",[t._v("禁止this指向全局")])]),t._v(" "),a("h4",{attrs:{id:"es6新增"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6新增"}},[t._v("#")]),t._v(" ES6新增")]),t._v(" "),a("ul",[a("li",[t._v("变量声明let、const")]),t._v(" "),a("li",[t._v("模板字符串")]),t._v(" "),a("li",[t._v("箭头函数、函数可以设置默认参数")]),t._v(" "),a("li",[t._v("解构赋值")]),t._v(" "),a("li",[t._v("展开符")]),t._v(" "),a("li",[t._v("数组方法forEach()、map()、filter()、reduce()、some()、every()")]),t._v(" "),a("li",[t._v("对象方法Object.is()比较两个值严格相等，例: Object.is(NaN,NaN)，返回true")]),t._v(" "),a("li",[t._v("数组创建，Array.from(), 将类数组或者可迭代对象转为数组")]),t._v(" "),a("li",[t._v("新的原始数据类型Symbol，通过Symbol('')创建")])]),t._v(" "),a("h4",{attrs:{id:"什么是单线程-和异步什么关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是单线程-和异步什么关系"}},[t._v("#")]),t._v(" 什么是单线程，和异步什么关系")]),t._v(" "),a("p",[t._v("单线程: 只有一个线程，只能做一件事。"),a("br"),t._v("\n在js中，单线程意味着所有的任务需要排队。然后当等待时间过长，就会拖延整个程序的执行。浏览器无响应往往就是因为一个脚本执行时间过长导致的。为了解决这个问题，浏览器将任务分为同步和异步。"),a("br"),t._v(" "),a("strong",[t._v("同步")]),t._v(": 在func返回的时候，得到预期的结果，那么这个函数就是同步的。"),a("br"),t._v(" "),a("strong",[t._v("异步")]),t._v(": 在func返回的时候，得不到预期的结果，而是在将来需要通过一些手段才能得到，那么这个函数就是异步的。")]),t._v(" "),a("h4",{attrs:{id:"作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),a("p",[t._v("作用域链可以理解为一组对象列表，包含父级和自身的变量对象，因此可以通过作用域链访问到父级里面的变量和函数。")]),t._v(" "),a("h4",{attrs:{id:"什么是原型、原型链、继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型、原型链、继承"}},[t._v("#")]),t._v(" 什么是原型、原型链、继承")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("原型: 所有的函数都有prototype属性(原型)，所有的对象都有_proto_属性。")])]),t._v(" "),a("li",[a("p",[t._v("原型链: 在JavaScript中，每个函数都有一个原型属性prototype指向自身原型，并且由这个函数作为构造函数而创建的对象会有一个_proto_属性指向这个原型，然而函数的原型是一个对象，所以这个对象有一个_proto_指向自己的原型，直到Object的原型，这样就形成原型链。")])]),t._v(" "),a("li",[a("p",[t._v("继承:")]),t._v(" "),a("ul",[a("li",[t._v("原型链继承，核心: 将Parent的原型指向Child。缺点: 父类构造函数中的引用类型（比如对象/数组），会被所有子类实例共享。其中一个子类实例进行修改，会导致所有其他子类实例的这个值都会改变")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Parent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fedaily'")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("getName")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Child")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里也可以直接写出Child.prototype = Parent.prototype")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是这样就不能访问到父类的构造函数的属性了，即this.name")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" child "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  child"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// fedaily")]),t._v("\n")])])]),a("ul",[a("li",[t._v("构造函数继承: 修改父类构造函数的this指向，在子类构造函数中执行父类构造函数，同时修改父类构造函数this为子类的this。 缺点: 所有方法都定义在构造函数中，每次都需要重新创建（对比原型链继承的方式，方法直接写在原型上，子类创建时不需要重新创建方法")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Parent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fedaily'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Child")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Parent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" child "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  child"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fe'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" child2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// child2.name === ['fedaily']")]),t._v("\n")])])]),a("ul",[a("li",[t._v("ES6提供了Class语法糖，同时提供了extends实现继承。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parent")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fedaily'")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n      "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parent")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里很重要，如果在this.topic = 'fe'后面调用，会导致this为undefined，具体原因可以详细了解ES6的class相关内容，这里不展开说明")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("topic "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fe'")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" child "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  child"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// fedaily")]),t._v("\n")])])])])]),t._v(" "),a("h4",{attrs:{id:"js的垃圾回收机制是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js的垃圾回收机制是怎样的"}},[t._v("#")]),t._v(" js的垃圾回收机制是怎样的")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("概述")]),t._v(": js中的垃圾回收机制是为了防止内存泄漏，不停的去寻找不在使用的变量，去释放掉它们所指向的内存，js的执行环境会管理代码执行中的内存。")]),t._v(" "),a("li",[a("strong",[t._v("变量的声明周期")]),t._v(": 局部变量，存在与函数中，当函数执行完毕后，该变量内存就被释放。全局变量，当浏览窗口被关闭时内存释放。")]),t._v(" "),a("li",[a("strong",[t._v("js垃圾回收方式")]),t._v(": 标记清除，引用计数"),a("br"),t._v("\n标记清除: 当变量进入执行环境时，垃圾回收器会将这个变量标记，离开环境时再度标记，然后清除。\n引用计数: 每次引用加一，被释放时减一，当这个值的引用次数变成 0 时，就可以将其内存空间回收")])])])}),[],!1,null,null,null);s.default=e.exports}}]);